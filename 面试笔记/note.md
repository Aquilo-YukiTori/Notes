高频面试题

业务技术难点项目
 - 前端绿幕抠像 FFMPEG  webcodecs
React原理
NodeJS
工程化
BFF层


八股

-------------

# React是什么

1. 是什么
用于构建用户界面的JS库

2. 能干什么
可以通过组件化的方式构建快速响应的大型web应用程序

3. 如何实现
- 声明式
- 组件化
- 跨端

-------------

# 在React中元素（Element）和组件（Component）有什么区别？

元素是构成React应用的基本构建块，是不可变的。
	- 元素是由ReactElement对象表示的，包含了类型、props、key等属性
组件是可复用的UI单元，具有逻辑和状态，能够响应用户交互和数据变化
	- 组件在内部通过React.Component类或函数被定义，并在渲染时被React调用，React会管理组件的生命周期和状态

------------

# 什么时候使用类组件（Class Component）?什么时候使用函数组件（Functional Component）?

根据定义形式的不同，分为类组件和函数组件


如果组件逻辑处理复杂，需要复杂情况的状态管理和副作用，或需维护已有类组件，那么类组件相较而言更适合
类组件可以使用错误边界，便捷的捕获子树中的错误并展示替代UI
在一般情况下，使用函数组件，性能、开发效率、应用质量等方面占优

------------

# 什么是React的refs? 为什么他们很重要？

refs是特殊的对象，用于直接访问DOM元素或组件实例
会创建一个包含current属性的对象，该属性在元素挂载时被赋值
在更新过程中，React会根据新旧虚拟DOM树比较，适时更新refs的指向

重要性
1. 是直接访问和操作DOM的手段，如聚焦、读取尺寸等
2. 与第三方集成
3. 在类组件中访问实例方法

------------

# React中的key是什么？为什么他们重要？

在渲染多个元素时，标识每一个元素的唯一性
在diff算法中起关键作用，在VDOM比对过程中，使元素可以被辨识为是否相同以复用元素，帮助识别真正发生变化的元素，从而更有效的更新DOM (diff算法)

------------

# Diff算法

VDOM是什么?
在web环境中，真实的DOM元素过重，绑定了太多的事件和方法
使用虚拟DOM，节点即一个对象，来描述和代表真实节点的信息
将对DOM的操作转化为JS的计算，将真实DOM节点转变为虚拟节点间的计算，减少了性能消耗

Diff算法是什么?
在VDOM中，用于高效比对两颗虚拟DOM树的算法，找出需要实际更新的部分，精准的更新真实DOM，从而提高性能

Diff核心思想
1. 逐层比较
2. 同层比较

### 核心是两颗树的比对
传递Diff算法中，采用递归加循环的方式比对，树中的每个节点都需同另一棵树中的每个节点进行比对，再计算最小转换方式，使复杂度来到O(n^3)

### 为什么是同层比较
React采用以下假设来简化Diff过程
  - 同层级的元素会更可能被更新
  - 同层级比较能避免过多的计算并节省内存
在WEB UI中DOM节点跨层级的移动操作较少，可以忽略不计，故只需进行逐层的同层比较

### 同层比较为什么使用DFS(深度优先算法)
  - DFS更适合遍历树结构，可以递归的处理子树，避免BFS带来的复杂层级管理
  - 节省内存，DFS可以逐层释放已经对比过的节点(层)，而BFS会保存每层的节点信息，增加了内存占用
  - 代码简洁，DFS通过函数的递归调用逐层深入，不需要为每层显式创建列表来存储节点，也不需要复杂的层级管理和标记系统，只需保存上下文
  	- BFS需要额外的队列来存储每层节点，以便逐层访问
  	- 每处理一个节点，都需要遍历他的所有子节点并添加进队列
  	- 队列的内存占用会随DOM树的层级和复杂度迅速增大

### 比较流程
  - 内容更改触发重新渲染，被影响的组件重新渲染生成新的VDOM，同旧VDOM比较
  - 比较新旧根节点是否相同，不相同直接替换，相同则对其子节点进行初步对比
    - 如何判断节点相同
      - key值
      - 标签名
      - 是否为注释节点
      - 是否定义了data属性
      - 为input时，type是否相同
    - 如何对子节点进行初步对比
      - 是否指向同一对象
      - 是否都有文本节点且不相同
      - 是否都有子节点
      - 若都有子节点，则进入下一步：同层节点比对
  - 进行同层节点比对
    - 同层节点比对是对新旧VDOM中同一层的节点进行比对(根节点之外)
    - 标记各节点应进行的操作：复用(是否要移动，移动至哪个位置)、删除、创建
    - 将标记的操作推入operation数组，后续调用以更新真实DOM
    - React使用简化的LIS算法(最长递增子序列)，Vue使用双端指针法
  - 进入可复用节点的子节点，即下一层

### 细节

两棵树进行逐层比较，可以转化为以下两个问题
1. 同层比较时，多个元素与多个元素之间的比较策略
2. 再细分一层，单个元素之间的比较细节

同层比较策略
一般指新老VDOM之间的同层的多元素比较，通过比较确认哪些元素需要操作
  - React
    简化的LIS算法
	可以看做是从左到右的重新排序以及增删，lastIndex是辅助排序，标定位置的索引和浮标
	细节
	  - 同层比较时，从新VDOM的当前层遍历开始
	  - 使用index和lastIndex进行比较，判断是否移动节点
	  - index是当前遍历的节点，在旧VDOM上的位置
	  - lastIndex是上次比较中index和lastIndex的最大值，初始值为0
	  - 通过比对index是否小于lastIndex，判断旧VDOM的元素是否该移动
	问题
	  - index小于lastIndex的比较算法意味着如果在旧VDOM中最后的元素，若在新VDOM中移至首位，则其他所有元素都需要移动
  - Vue
    Dep.notify -> render -> patch -> isSameNode -> patachVnode
	双端指针法
	在新旧VDOM的双端各有指针，旧VDOM的指针分别同新VDOM的指针进行比较
	  - 这样的头尾指针比对的操作，也可以快速检测出reverse操作，加快diff效率
	相同则对旧节点进行移动操作，并将当前比对的指针向起始的另一端靠近，继续下一轮比对
	若指针比对后未有任何一对相同，则转换机制，将所有旧节点的key做一个key和下标index的映射，再用新节点的key找出可以复用的节点及其位置
	key作为重要比对依据，仍然需求其独特性和唯一标识性

### VDOM+Diff算法是否一定比直接操作DOM更快？
1. 在初次渲染时，需要多加一步生成VDOM的步骤，理论上会更慢
2. 在后续更新与渲染阶段，若与直接操作DOM相比，VDOM会更快
3. VDOM+Diff算法提供的是一个在大多数场景下都有一定下限的通用型性能优化(性价比)，但在特殊场景，他比不过对于进行针对性优化后的直接操作DOM的方案
  这些场景通常是
  - 高频率的动画更新
    - 虚拟DOM需要在每一帧重新生成并比对，对于每秒几十或几百帧的情况，性能消耗将不可忽视
    - 直接操作DOM或使用Canvas/WebGL(硬件加速)进行渲染，可以避免虚拟DOM的重计算和Diff对比，从而实现更高速的渲染
  - 大规模动态列表更新
  	- 非常大的动态列表，项目频繁添加、删除或排序，且列表项内容复杂
  	- 使用虚拟DOM易导致大量节点比对和重排，产生性能瓶颈
  	- 手动操作DOM可以避免不必要的节点比对和更新
  	- 这种场景使用虚拟列表可能效果更好
  - 复杂的可视化图表/数据图形
  	- 涉及复杂数据绑定和更新以及特定图形和交互
  	- 直接操作canvas、SVG和webgl，可以针对性的控制每个元素的绘制和更新，避免框架虚拟DOM的抽象和计算，在性能上取得优势
  	- 对于动态实时更新的图标，直接操作DOM或通过底层渲染API进行优化，将显著提高性能
  	- 在实际场景中，常通过如react的突围机制，让第三方库通过使用canvas或webgl等来管理和控制复杂可视化图形（Echarts，D3.js）

------------

# 虚拟列表

### 场景
  不能使用分页方式或懒加载来加载列表数据，列表数据过多在渲染和更新时需要耗费较多时间，故使用虚拟列表

### 定义
  虚拟列表是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到较高的渲染性能

### 实现
核心逻辑是动态计算可见区域的内容索引，根据索引渲染数据

  子元素定高的情况
  1. DOM由三部分组成
  	- 最外层的container盒子C
  	- 被包裹的列表A，撑开盒子C以实现滚动条功能，内部为空，只有高度，高度由 子元素高度 * 数量 决定
  	- 虚拟列表B，只有固定数量的元素，随A的滚动而移动，并对应计算及更新显示内部元素
  	  - 虚拟列表本身是绝对定位，使用translate3d实现元素向上滚动，列表位置不变
  	  	- translate3d只影响元素的视觉展示位置，而不改变元素的DOM排列顺序
  	  - 在滚动时计算应展示的元素的索引，并更新展示元素
  	    - 计算开始元素的索引：Math.floor( ScrollTop / itemSize )
  	    - 计算结束元素的索引：开始元素的索引 + 应展示的元素数量
  	    - 列表展示的数据：listData.slice(开始索引, 结束索引)
  	    - 计算滚动后的偏移量：scrollTop - ( ScrollTop % itemSize )
  子元素动态高度的情况
  1. 预先知道高度可以扩展itemSize并传入
  2. 将列表项预先渲染至屏幕外的canvas等，测量其高度并缓存，但对于低端设备可能不能接受
  3. 传入预估高度，缓存之前的数据平均高度，先以 预估高度/之前的平均高度 渲染，在滚动过程中再计算高度并即时传给负责滚动条的空列表
     滚动时，通过滚动进度决定计算策略，对于当前剩余进度大于某值的情况下：通过剩余数据条数+以滚动过的数据的平均高度，简单计算剩余的高度
     对于当前剩余进度小于某值的情况：视为快接近底部或一开始数据量就不够，需要更频繁且更精准的计算，且留出余量，以免用户不能滚动从而无法看到最底部的数据
  一些细节
  1. 在滚动过快时，因元素过少会短暂出现白屏，所以需要额外渲染一些元素以作为缓冲
  2. 滚动事件触发过快，可以使用节流或IntersectionObserver替换监听scroll事件，监听目标元素是否出现在可视区域内，在监听的回调事件中执行可视区域数据的更新
  3. 当子项中有图片等资源需要异步获取，获取后会撑开item导致高度变化，需要额外使用ResizeObserver监听列表项内容区域的高度变化，从而获得真高度用以计算

### 其他
  同样的场景，可以考虑简单方案：分批渲染。 相当于无限加载的变种

------------


# 生疏API

### IntersectionObserver

### ResizeObserver

### requestAnimationFrame

------------

# 约束性组件与非约束性组件

### 定义
  - 约束性组件，组件的状态由React组件的state完全控制
  - 非约束性组件，元素的值由DOM自身维护，需要用ref来访问DOM

### 异同
  - 非约束性组件值由DOM自身维护
  - 非约束性组件是双向数据流
  - 非约束性组件适用于简单场景(文件上传，一次性数据输入，简单表单)
  - 非约束性组件代码简单但缺少灵活性，且无法感知状态

### 其他

受控组件的性能瓶颈在哪
1. 高频状态更新
2. 渲染粒度过大
3. 状态管理复杂
4. 虚拟DOM更新压力

常用优化方法
1. React.memo
2. 局部状态
3. 节流防抖
4. 虚拟化，如虚拟滚动

------------

# 在哪个生命周期中你会发出Ajax请求？为什么？

### React的生命周期

类组件

1. 挂载阶段
 - constructor(props)
   - 初始化组件状态、绑定方法
 - static getDerivedStateFromProps(props, state)
   - 根据新的props更新state，是静态方法，无法访问this
   - 在每次组件初始化或收到新的props时触发
 - render()
   - 纯函数，返回要渲染的内容
   - 不执行副作用
 - componenDidMount()
   - 在组件挂载到DOM后调用，可进行副作用操作(如Ajax，订阅事件等)

2. 更新阶段
 - static getDerivedStateFromProps(props,state)
   - 与挂载阶段相同，在更新时触发
 - shouldComponentUpdate(nextProps, nextState)
   - 控制是否需要重新渲染，默认返回true
   - 可避免不必要的重新渲染
 - render()
   - 与挂载阶段相同
 - getSnapshotBeforeUpdate(prevProps, prevState)
   - 在DOM更新前被调用，可以读取当前DOM状态并返回值作为componentDidUpdate的参数
 - componentDidUpdate(prevProps, prevState, snapshot)
   - DOM更新后被调用，一般在此处理副作用
   - 参数为getSnapshotBeforeUpdate的返回值

3. 卸载阶段
 - componentWillUnmount()
   - 在组件销毁前清理资源

4. 错误处理阶段
 - static getDerivedStateFromError(error)
   - 捕获子组件抛出的错误，并更新状态
 - componentDidCatch(error, info)
   - 捕获错误并记录信息

函数式组件
函数式组件通过hooks提供等效能力

componentDidMount        useEffect(() => {...}, [])
componentDidUpdate       useEffect(() => {...})
componentWillUnmount     useEffect(() => {... return () => {...}}, [])
getSnapshotBeforeUpdate  不直接支持，可自行实现逻辑

### 为什么选择componentDidMount
1. 组件已挂载
  - componentDidMount在组件第一次渲染后触发，此时DOM已经加载完成，任何需要与用户交互或外部系统交互的操作都可以安全执行
2. 不会阻塞初次渲染
  - componentDidMount上一步是render，如果在render中发起请求，可能会导致阻塞，降低性能或导致UI卡顿
3. 确保操作安全
  - 在componentDidMount中发出的请求不会因组件未完成初始化而导致问题

------------

# shouldComponentUpdate有什么用？为什么它很重要？

### 定义
在组件更新前被调用，用于控制组件是否需要更新(重新渲染)

接收参数
  - nextProps: 更新后的props
  - nextState: 更新后的state

返回值
  - true: 默认，组件将更新
  - false: 组件不会更新，跳过后续的渲染和render调用

### 重要性
  性能优化
  - 组件更新导致的虚拟DOM生成与比对、操作真实DOM，是性能瓶颈的重要因素
  - 该方法可让用户控制是否重新渲染，避免不必要的更新，甚至自定义更新逻辑，提升渲染性能

### 其他
  - 类组件有一个PureComponent，是Component的子类，相当于自定义了一个 shouldComponentUpdate，该方法将浅比较props和state
    以决定是否重新渲染

### 在函数组件中的实现
在函数式组件中，没有对应的方法，函数式组件本质上是纯函数，没有声明周期的概念，函数式组件是通过 Hooks 才引入了生命周期能力
  - 使用 React.memo 实现类似功能
    React.memo 是 React 提供额度高阶组件，用于对函数组件的 props 进行浅比较，避免不必要的重新渲染
    作用类似于 PureComponent 实现的 shouldComponentUpdate

    可以通过 React.memo 的第二个参数areEqual自定义比较逻辑，类似 shouldComponentUpdate

    React.memo 缓存计算结果，优化组件的重新渲
    React.useCallback 缓存回调函数

  - 在某些特殊场景中，可能也需要开发者自行管理渲染逻辑，可以通过拆分组件并在父组件中控制子组件的渲染条件

------------

# 什么是纯函数？

### 定义
纯函数式编程概念，有以下特点        
1. 输入决定输出
  同样的输入总是得到相同的输出
2. 无副作用
  不会修改外部状态或依赖外部状态，即与外部状态无关联

### 为什么没有生命周期?
因为生命周期是和状态、外部环境相关的，而纯函数是完全和外部环境解耦的，因此他不需要也不具备生命周期

### 优点
1. 可预测性
  - 输入决定输出
  - 无隐式依赖，逻辑清晰
2. 易于测试和调试
  - 输入决定输出，意味着无需构造复杂的测试环境
  - 测试的边界清晰，只需要提供收入参数即可验证函数的正确性
3. 更容易并行化
  - 无副作用意味着线程安全，在多线程环境下可以安全并发执行
  - 由于输入和输出一一对应，可以使用惰性计算和缓存优化性能
4. 可组合性
  - 与外部环境解耦，可以轻松组合在一起实现复杂功能
5. 无隐式副作用
  - 不改变外部状态，也不依赖外部状态，使其不容易出现意外
  - 副作用在特定地方集中管理，使代码逻辑清晰
6. 易于优化
  - 输出依赖于输入，可以使用缓存技术避免重复计算

### 适用场景
1. 前端框架开发
2. 复杂算法的实现
3. 并发编程

------------

# React.useCallback有什么用？使用场景?

### 定义
React.useCallback是React提供的一个Hook，用于缓存函数的引用，以避免在组件重新渲染时创建新的函数实例
常和memo搭配使用
用来解决函数作为引用型变量，每次重新渲染都会更新引用，将其作为依赖时不够稳定的问题

### 使用场景
1. 避免子组件重复渲染
当父组件重新渲染时，如果传递给子组件的函数发生了引用变化(未使用useCallback)，即使函数的逻辑没变，子组件仍会重新渲染

2. 在依赖中使用稳定的回调函数
当使用useEffect或其他Hooks时，如果依赖的回调函数在每次渲染时都会改变，会导致不必要的副作用


------------

# Hooks是什么？原理？

### 定义
Hooks是React16.8引入的特性，为函数组件提供状态管理和生命周期及其他React特性
Hooks提供了一种无需使用类组件即可管理状态和副作用的方式

常见Hooks
useState
useEffect
useContext
useReducer
useRef
useMemo
useCallback

### 原理

1. 