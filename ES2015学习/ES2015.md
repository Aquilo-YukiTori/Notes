## ES2015

### let命令
##### 可代替var

区别在于let声明的代码只在他所在的代码块有效
```
for(let i=0;i<10;i++){};
```
这样以往的常见面试题之for循环中延迟输出index的结果就会变得不那么出人预料了

向在for循环中延迟输出index，上例用var声明的结果将会是10个10，而用let则会是正常的1到10

##### 不存在变量提升

var声明的变量因为变量提升所以可以在声明之前调用，值为`undefined`，但let纠正了这个错误

##### 暂时性死区

若一个作用域中有用let声明的变量，不管这个变量是否在全局拥有同名的变量，如果在此作用域内的声明前调用，调用时都会报错，const也是如此，这被称为暂时性死区

在暂时性死区内，即使使用`typeof`命令去调用变量也会报错，而在变量无声明的时候，用typeof只会返回undefined

这个声明的'临界点'在于声明语句的运行结束之时，所以
```
let x = x；
```
这种也是会报错的

##### 不允许重复声明

let不允许在相同作用域内，重复声明同一个变量

### 块级作用域

JS里没有块级作用域，只有函数作用域和全局作用域，这意味着你在函数内部的if语句或者for循环中声明的变量其实都是属于函数作用域的

let解决了这个问题，让变量只在其所在的块级作用域起作用，外部作用域正常情况无法访问到内部块级作用域内声明的变量

块级作用域的实现实际取代了立即执行函数的大部分功能，因为只有函数作用域和全局作用域，所以用立刻执行函数人工制造一个块级作用域成了常用手段，而ES6中正常即可实现此目的

##### 在块级作用域中声明函数

ES6允许在块级作用域中声明函数，也就是在块级作用域中使用函数声明。即
```
function(){}
```

但因为这与之前的处理规则有很大不同，势必会对之前的代码产生很大影响，为了减轻因此产生的不兼容问题，ES6规定**浏览器的实现**可以不严格遵守ES6关于此的规定，有自己的行为方式

因此导致的环境差异问题难以统一与解决，所以暂时应避免在块级作用域中使用函数声明，如果必要，则应用函数表达式予以替代
```
let a = function(){}
```

这一块儿的结论就是，对于ES6环境内的块级作用域声明函数，应该用let和函数表达式明确的让其只在块级作用域内起效果，这样万无一失

### cosnt命令

const声明一个只读的常量，一旦声明就无法更改，必须在初始化时就赋好值

const的作用域和let相同，只在声明所在的块级作用域内有效

const声明的常量与let相同，没有声明提升，所以有暂时性死区

const同let一样，不可重复声明

##### 本质

同深浅拷贝的问题一样，对于简单数据，const的变量无法改动，这毫无疑问，但对于复合类型的数据，对象和数组，变量保存的只是一个指向实际数据的指针，而此时的const也只能保证这个指针无法改动，即这个变量总是指向某块内存地址，但内存地址保存的是什么，他就无能为力了

这就相当于C++中的`int* const p = &a`一样，const保证的是指针p指向a的地址，但a保存的是什么，他无法涉及

所以当const一个对象时，可以为对象增添删改，数组也是如此

这显然不符合本来想达到的效果，所以对于复合类型的数据，可以使用`Object.freeze()`冻结方法使其无法修改

除了将对象本身冻结，对象的属性也应冻结，如
```
var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
```

### 顶层对象的属性

顶层对象，浏览器是window，node是global

在浏览器中，全局变量和顶层变量是一件事，都是window，但实际上，从许多原因上，这两个概念都需要区分开

ES6中，一方面兼容旧代码，`var`和`function`声明的全局变量，依旧是顶层对象的属性，另一方面，`let`、`const`、`class`声明的全局变量，不属于顶层对象的属性，从而逐渐将全局变量和顶层对象区分开

### global对象

ES5中定义的顶层对象，在各种实现中却并没有统一

-浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
-浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self
-Node 里面，顶层对象是global，但其他环境都不支持。

所以如果想用通用的代码取得顶层对象，会比较困难

而在语言层面引入global作为顶层对象从而统一顶层对象的实现，现在仍然只是个提案，但可以用垫片库system.global模拟这个实现

----------

### 解构赋值

##### 数组的解构赋值
```
//普通的数组解构赋值
let [a,b,c] = [1,2,3];
//嵌套的数组解构赋值
let [a, [b,c]] = [1, [2,3]];
//空占位的数组解构赋值
let [ , ,c] = [1,2,3];
let [a, ,c] = [1,2,3];
//用...操作符获得对应位置及剩余位置的值
let [a, ...b] = [1,2,3];
//赋值位置较少的情况
let [a] = [1,2,3];
a // 1
//赋值位置较多的情况
let [a,b,..c] = [1];
a // 1
b // undefined
c // []

//解构不成功的情况
let [b] = [];
let [a,b] = [1];
//以上两种情况的b都是undefined

//除了数组，只要数据结构具有Iterator接口，都可以采用数组形式的解构赋值

// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};

//Set结构
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"

//Generator函数


//可以为赋值位置指定默认值，但只有当其严格等于(===)undefined时才会生效，如null就不会生效
let [a = 1] = [undefined];

//默认值可以是一个表达式，但只有当确定默认值需要生效时，表达式才会运行求值

//默认值可以引用解构赋值的其他变量，但需要已经声明，不然会引发let的暂时性死区问题
let [x=1,y=x] = [];

```

##### 对象的解构赋值
```
//普通的对象解构赋值
let {a,b} = {a: '1',b: '2'};
//不同于数组解构赋值的依靠次序进行，对象的属性没有次序，所以只有当变量与属性同名时才可正确赋值
let {c} = {a: '1',b: '2'};
c // undefined

//如果需求变量名与属性名不一样的解构赋值
let {a: x, b: y} = {a: '1', b: '2'};
x // '1'
y // '2'

//所以其实其内部实现方式是先找到同名属性，然后赋给对应的变量
let {a: a, b: b} = {a: '1', b: '2'};

//也可用于嵌套结构的对象
let obj = {a: ['1', {b: '2'}]};
let {a:p, a: [x], a: [,{b:y}]} = obj;
p // obj
x // '1'
y // '2'

//需要注意的是，对象嵌套解构赋值较复杂，需要区分开模式和变量两个概念
//模式是用来在对象中定位的，因为对象的属性并不按次序排列，所以需要指定的名字查找位置，也即是模式
//而变量则是赋值的目标，是你自己的定义的变量，可以在赋值后使用的变量
//上例中，`a:p`a就是模式，由于处在对象的第一层，所以也会直接去obj的第一层查找名为a的属性，然后赋值给变量p
//`a: [x]`也是一样，查找到名为a的属性后，并且确定他是一个数组，于是按数组的规则解构，那么直接使用一个'x'或'x,'就可以获取到数组第一个位置的值
//`a: [,{b: y}]`较复杂，a是模式为了查找到对象中的元素，下一层中是数组解构，所以无需名字，只需要指定位置，所以此时用一个','表示取第二个位置的值，第二个位置是个对象，要取其中的指定值就又需要指定名字查找，就是'b'，之后将其赋给变量y

//对象的解构也可使用默认值
//同数组解构赋值的默认值规则一样

//如果将一个已经声明的变量用于解构赋值，必须注意写法
let x;
({y:x} = {y:1});

//对象的解构赋值，对于对象内置属性和方法的复制来说，会变得非常简单，因为是直接通过名字查找的
let {log, sin ,cos} = Math;
//但注意，解构赋值是**浅复制**，对于对象中的复杂类型的数据，只会复制其指针

//因为数组本身是特殊的对象，所以可以对数组进行对象的解构赋值，模式是数组的index
let arr = [1,2,3];
let {0: a, [arr.length-1]: b} = arr;
//上例中方括号的写法为属性名表达式，属于新的对象的扩展
```

##### 字符串的解构赋值
```
//字符串在解构赋值时，是被转换成了类似数组的对象，每个字符按次序排列在数组中
let {a,b,c} = '123';
a // 1
b // 2
c // 3

//类似数组的对象都有一个length属性，因为字符串解构赋值是被转换成类似数组的对象，数组其实也是特殊的对象，所以追根究底，就是对象的解构赋值，所以无论是通过index找到的字符，还是通过length属性找到的对应的属性，都是可以解构赋值的
```

##### 数值和布尔值的解构赋值

同样，会先将数值和布尔值转换成对象，然后进行对象的解构赋值操作

##### 函数参数的解构赋值
```
//实际上就是将数组和对象的解构赋值
function([a,b]){};
function({}){};
//同数组和对象的解构赋值规则相同

//需要注意的是，在设置默认值时，要注意对象
function({x=0, y=0}){};
//这样的默认值设置无论是有一个参数不存在，或是都不存在的情况下，都将使用默认值
function(){{x,y} = {x:0, y:0}};
//而这样的则是为函数的整个参数对象设置默认值，也就是arguments对象，所以只有当整个参数对象为undefined时，才会使用默认值，无论是空对象还是缺少参数，都不会使用默认值

```

##### 圆括号问题

在某些情况下使用解构赋值并使用圆括号会导致一些歧义的产生，所以建议是最好不要在模式中放置圆括号

不能使用圆括号且使用就会报错的场景与情况有很多，而能使用圆括号的情况只有一种：**赋值语句的非模式部分，可以使用圆括号**

如`[(a)] = [1]`这种数组解构赋值，无需指明模式，a直接就是变量

又如`({p: (d)} = {})`这种对象解构赋值，p是模式，d是变量，圆括号用在d上，以及整个赋值表达式上，都是可以的

### 用途

1.交换变量的值
```
[x,y] = [y,x]
```
2.从函数返回多个值

当函数需要返回多个值时，多是以对象或数组形式返回，用解构赋值可以轻松的分解获得这些数据

3.函数参数的定义和默认值

多见于参数为一个对象，这样的解构赋值甚至不需要次序，和解构赋值的默认值配合使用，使函数内部的初始化工作甚至可以在函数声明时就完成预设
```
function(data, {
	a = true,
	b = function(){},
	c = 1,
	d = []
	}){};
```



4.提取JSON数据

JSON其实也是特殊的对象，所以只要指定键名(属性名)，解构赋值也会变得非常轻松和短

5.遍历map结构(for of方法)

Map结构暂时没了解，等之后了解后更改此部分内容
```
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world
```

6.输入模块的指定方法

实际上也是对象方法和属性的解构赋值
```
const { SourceMapConsumer, SourceNode } = require("source-map");
```
--------------------------------

### 字符串的扩展

##### 总览

* codePointAt &emsp; 用于正确返回4个字节存储的字符的Unicode值
* String.fromCodePoint &emsp; 用需要4个字节存储的字符的Unicode值，正确的返回字符
* normalize &emsp; 用于Unicode正规化
* includes &emsp; 用于在字符串中查找是否包含目标字符串
* startsWith &emsp; 用于在字符串查找是否头部是目标字符串
* endsWith &emsp; 用于在字符串中查找是否尾部是目标字符串
* repeat &emsp; 用于重复字符串
* padStart &emsp; 用于从头部补全字符串
* padEnd &emsp; 用于从尾部补全字符串
* matchAll &emsp; 用于返回正则匹配的所有值
* String.raw &emsp; 用于转义字符串
* ForOf &emsp; 可以正确遍历含有需要4个字节存储的字符的字符串
* ` ` &rmsp; 模板字符串与标签模板

##### 字符的Unicode表示法

Unicode的基础面的码点范围是U+0000~U+FFFF的65536个字符，在JS中用\uxxxx就可以表示这一范围的基础Unicode码点所代表的字符

而对于超出这个范围的字符，之前的JS中需要用UTF16的四字节也就是两个双字节来表示
如`\uD842\uDFB7`

而ES6中开始支持高于双字节的码点，如`\u{20BB7}`就可以正确解读该字符，而在之前只会解读为`\u20BB + 7`从而出现乱码或显示错误

```
'\z' === 'z'  // true 转义字符
'\172' === 'z' // true ASCAII码
'\x7A' === 'z' // true 十六进制
'\u007A' === 'z' // true Unicode码
'\u{7A}' === 'z' // true ES6的支持三字节及四字节的Unicode表示法
```

##### codePointAt()

charCodeAt的加强版

JS以UTF-16的格式储存字符，每个字符固定为2个字节，所以对于需要4个字节储存的字符(UNICODE码点大于FFFF的字符)，JS会认为他们是两个字符

如汉字“𠮷”的码点是0x20BB7，用UTF-16编码方式则为0xD842 0XDFB7，需要4个字节存储，所以JS识别为两个字符
```
let x = "𠮷";
x.length //2 错误返回长度，被当成了两个字符

x.charAt(0) //''
x.charAt(1) //'' 用charAt无法正确返回字符

x.charCodeAt(0) //55362
x.charCodeAt(1) //57271 用charCodeAt返回的是前两个字节和后两个字节的十进制值

但无论如何，这都是一个字符，都应被当成一个字符返回，且应正确返回码点，而不是分别当成两个字节返回
```

**初步方法**

相当于是少了一个将字符从UTF-16格式转为Unicode格式输出的过程

ES6提供了codePointAt方法，能够正确处理4个字节储存的字符
```
let s = '𠮷a';

s.codePointAt(0) // 134071 𠮷的正确的Unicode值
s.codePointAt(1) // 57271 𠮷的后两个字节的十进制值

s.codePointAt(2) // 97 a的十进制值
```
虽然没有完全的解决问题，但在提取第一个字符时正确返回了该字符的Unicode的十进制值

**进阶方法**

但在定位的时候，一个字符占据了两个位置仍然会有诸多不便

解决方法是用forof循环对字符串进行遍历代替直接用下标定位

forof会正确的识别32位的UTF-16字符
```
let s = '𠮷a';
for (let ch of s) {
  console.log(ch.codePointAt(0).toString(16));
}
// 20bb7
// 61
```
codePointAt也是测试一个字符是由两个字节还是四个字节组成的便捷方法

##### String.fromCodePoint()

ES5的String.fromCharCode方法的加强版

同样是因为无法正确的识别32位的UTF-16字符(Unicode码点大于FFFF)

ES6提供了String.fromCodePoint方法用于从码点返回字符，支持大于FFFF的Unicode码点，支持多个参数，多个参数将都会转换成字符，并且合并成字符串返回

注意: fromCodePoint方法定义在String对象上，而CodePointAt方法定义在字符的实例对象上

##### 字符串的遍历器接口

ES6为字符串添加了遍历器接口，使字符串可以被forOf循环遍历

forOf遍历字符串的最大优点就是可以识别大于FFFF的码点，这是传统的for循环所不能做到的

##### normalize()

在表示欧洲语言的语调符号以及重音符号时，Unicode提供了两种方法，一种是直接提供带重音符号的字符，另一种是提供合成符号，即用原字符和重音符号合成一个字符，但这在JS中将导致其被识别为两个字符，并且并不与第一种字符相等

ES6提供了字符串实例的normalize方法用于将字符的不同表示方法统一为同样的形式啊，这称为Unicode正规化

normalize接受一个参数来指定正规化的方式<br>
NFC标准等价合成<br>
NFD标准等价分解<br>
NFKC兼容等价合成<br>
NFKD兼容等价分解

合成与分解表示返回的是合成后的字符还是分解后的多个简单字符<br>
标准等价和兼容等价的区别在于兼容等价只需要在语义上存在等价，而视觉上不需等价

注意:normalize方法目前不能识别三个或三个以上字符的合成，这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断

##### includes(),startsWith(),endsWith()

ES6提供了三个新的方法用于在字符串中寻找是否包含某字符串

1. includes

返回布尔值，表示是否找到了参数字符串

2. startsWith

返回布尔值，表示参数字符串是否在原字符串的头部

3. endsWith

返回布尔值，表示参数字符串是否在原字符串的尾部

-----

这三个方法都支持第二个参数，用来表示开始搜索的位置

endsWith略有不同，第二个参数是针对前n个字符，其他两个则是针对第n个位置直到字符串结束

注意:这三个方法值返回布尔值，在使用includes时尤其注意，与indexOf不一样的是，他不会返回具体的位置

##### repeat()

用于返回一个新字符串，将原字符串重复n次

参数如果是小数，会被取整(注意不是四舍五入)

参数不可为负数或Infinity

参数0~-1等同于0，NaN等同于0

如果参数是字符串，则会先转换成数字

##### padStart(),padEnd()

用于字符串补全长度，如果某个字符串不够指定长度，会在头部或尾部补全

接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串

padStart用于头部补全，padEnd用于尾部补全

如果原字符串的长度等于或大于指定的最小长度，则返回原字符串(只补全，不截取)

如果省略第二个参数，则默认用空格补全长度

**padStart的常见用途是为数值补全指定位数以及补全字符串格式**

##### matchAll()

用于返回一个正则表达式在当前字符串的所有匹配

##### 模板字符串

用反引号标识(`)，可以直接在模板字符串中嵌入变量
```
var str = `hello ${name}, 1 2 3 4 ${para}`;
```

如果在模板字符串中需要使用反引号，则前面要使用反斜杠转义

如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中

模板字符串中嵌入变量，需要将变量名写在${}之中

大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性

模板字符串之中还能调用函数

如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法

模板字符串甚至还能嵌套
```
const tmpl = addrs => `
  <table>
  ${addrs.map(addr => `
    <tr><td>${addr.first}</td></tr>
    <tr><td>${addr.last}</td></tr>
  `).join('')}
  </table>
`;
```

##### 标签模板

模板字符串紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串，这被称为标签模板功能

```
alert`123`
等同于
alert(123)
```

如果模板字符串中有变量，则会优先将模板字符串处理成多个参数，再调用参数
```
var para1 = 10,
    para2 = 20;
func`str1 ${para1} str2 ${para2}`
在处理后的参数顺序应为
func(['str1 ', ' str2 '], 10, 20);
即将没有被变量替换的部分放在一个数组里作为第一个参数，后续参数分别为顺序排列的被变量替换后的值
```
标签模板用于过滤HTML字符串，防止用户输入恶意内容

相当于在用标签模板时，因为自动将不要替换的字符串和要替换的变量分离，所以对于用户输入的信息，也就是要替换的变量进行校验会非常方便，校验过后再与其他字符串拼合返回，形成了一个便利的过滤字符串函数

另一个应用，是用于多语言转换

用模板处理函数对于字符串进行基于语言环境的替换

注意: 模板处理函数的第一个参数，实际上有一个raw属性，保存的是raw属性
```
console.log`123`
// ["123", raw: Array[1]]
```

##### String.raw()

String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串

如果原字符串的斜杠已经转义，那么String.raw会进行再次转义

String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用

String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组

##### 模板字符串的限制

在模板字符串中内嵌其他语言时，其他语言的一些习惯于具有特殊含义的字符在JS中难免会出现矛盾或者报错，此时若使用模板处理函数，模板处理函数会因为JS引擎觉得因报错而返回undefined，而raw属性则会返回原始字符串，便于用户在模板处理函数中对其进行处理，这只在标签模板时生效。

--------------------------------

### 正则的扩展
