## ES2015

### let命令
##### 可代替var

区别在于let声明的代码只在他所在的代码块有效
```
for(let i=0;i<10;i++){};
```
这样以往的常见面试题之for循环中延迟输出index的结果就会变得不那么出人预料了

向在for循环中延迟输出index，上例用var声明的结果将会是10个10，而用let则会是正常的1到10

##### 不存在变量提升

var声明的变量因为变量提升所以可以在声明之前调用，值为`undefined`，但let纠正了这个错误

##### 暂时性死区

若一个作用域中有用let声明的变量，不管这个变量是否在全局拥有同名的变量，如果在此作用域内的声明前调用，调用时都会报错，const也是如此，这被称为暂时性死区

在暂时性死区内，即使使用`typeof`命令去调用变量也会报错，而在变量无声明的时候，用typeof只会返回undefined

这个声明的'临界点'在于声明语句的运行结束之时，所以
```
let x = x；
```
这种也是会报错的

##### 不允许重复声明

let不允许在相同作用域内，重复声明同一个变量

### 块级作用域

JS里没有块级作用域，只有函数作用域和全局作用域，这意味着你在函数内部的if语句或者for循环中声明的变量其实都是属于函数作用域的

let解决了这个问题，让变量只在其所在的块级作用域起作用，外部作用域正常情况无法访问到内部块级作用域内声明的变量

块级作用域的实现实际取代了立即执行函数的大部分功能，因为只有函数作用域和全局作用域，所以用立刻执行函数人工制造一个块级作用域成了常用手段，而ES6中正常即可实现此目的

##### 在块级作用域中声明函数

ES6允许在块级作用域中声明函数，也就是在块级作用域中使用函数声明。即
```
function(){}
```

但因为这与之前的处理规则有很大不同，势必会对之前的代码产生很大影响，为了减轻因此产生的不兼容问题，ES6规定**浏览器的实现**可以不严格遵守ES6关于此的规定，有自己的行为方式

因此导致的环境差异问题难以统一与解决，所以暂时应避免在块级作用域中使用函数声明，如果必要，则应用函数表达式予以替代
```
let a = function(){}
```

这一块儿的结论就是，对于ES6环境内的块级作用域声明函数，应该用let和函数表达式明确的让其只在块级作用域内起效果，这样万无一失

### cosnt命令

const声明一个只读的常量，一旦声明就无法更改，必须在初始化时就赋好值

const的作用域和let相同，只在声明所在的块级作用域内有效

const声明的常量与let相同，没有声明提升，所以有暂时性死区

const同let一样，不可重复声明

##### 本质

同深浅拷贝的问题一样，对于简单数据，const的变量无法改动，这毫无疑问，但对于复合类型的数据，对象和数组，变量保存的只是一个指向实际数据的指针，而此时的const也只能保证这个指针无法改动，即这个变量总是指向某块内存地址，但内存地址保存的是什么，他就无能为力了

这就相当于C++中的`int* const p = &a`一样，const保证的是指针p指向a的地址，但a保存的是什么，他无法涉及

所以当const一个对象时，可以为对象增添删改，数组也是如此

这显然不符合本来想达到的效果，所以对于复合类型的数据，可以使用`Object.freeze()`冻结方法使其无法修改

除了将对象本身冻结，对象的属性也应冻结，如
```
var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
```

### 顶层对象的属性

顶层对象，浏览器是window，node是global

在浏览器中，全局变量和顶层变量是一件事，都是window，但实际上，从许多原因上，这两个概念都需要区分开

ES6中，一方面兼容旧代码，`var`和`function`声明的全局变量，依旧是顶层对象的属性，另一方面，`let`、`const`、`class`声明的全局变量，不属于顶层对象的属性，从而逐渐将全局变量和顶层对象区分开

### global对象

ES5中定义的顶层对象，在各种实现中却并没有统一

-浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
-浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self
-Node 里面，顶层对象是global，但其他环境都不支持。

所以如果想用通用的代码取得顶层对象，会比较困难

而在语言层面引入global作为顶层对象从而统一顶层对象的实现，现在仍然只是个提案，但可以用垫片库system.global模拟这个实现

----------

### 解构赋值

##### 数组的解构赋值
```
//普通的数组解构赋值
let [a,b,c] = [1,2,3];
//嵌套的数组解构赋值
let [a, [b,c]] = [1, [2,3]];
//空占位的数组解构赋值
let [ , ,c] = [1,2,3];
let [a, ,c] = [1,2,3];
//用...操作符获得对应位置及剩余位置的值
let [a, ...b] = [1,2,3];
//赋值位置较少的情况
let [a] = [1,2,3];
a // 1
//赋值位置较多的情况
let [a,b,..c] = [1];
a // 1
b // undefined
c // []

//解构不成功的情况
let [b] = [];
let [a,b] = [1];
//以上两种情况的b都是undefined

//除了数组，只要数据结构具有Iterator接口，都可以采用数组形式的解构赋值

// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};

//Set结构
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"

//Generator函数


//可以为赋值位置指定默认值，但只有当其严格等于(===)undefined时才会生效，如null就不会生效
let [a = 1] = [undefined];

//默认值可以是一个表达式，但只有当确定默认值需要生效时，表达式才会运行求值

//默认值可以引用解构赋值的其他变量，但需要已经声明，不然会引发let的暂时性死区问题
let [x=1,y=x] = [];

```

##### 对象的解构赋值
```
//普通的对象解构赋值
let {a,b} = {a: '1',b: '2'};
//不同于数组解构赋值的依靠次序进行，对象的属性没有次序，所以只有当变量与属性同名时才可正确赋值
let {c} = {a: '1',b: '2'};
c // undefined

//如果需求变量名与属性名不一样的解构赋值
let {a: x, b: y} = {a: '1', b: '2'};
x // '1'
y // '2'

//所以其实其内部实现方式是先找到同名属性，然后赋给对应的变量
let {a: a, b: b} = {a: '1', b: '2'};

//也可用于嵌套结构的对象
let obj = {a: ['1', {b: '2'}]};
let {a:p, a: [x], a: [,{b:y}]} = obj;
p // obj
x // '1'
y // '2'

//需要注意的是，对象嵌套解构赋值较复杂，需要区分开模式和变量两个概念
//模式是用来在对象中定位的，因为对象的属性并不按次序排列，所以需要指定的名字查找位置，也即是模式
//而变量则是赋值的目标，是你自己的定义的变量，可以在赋值后使用的变量
//上例中，`a:p`a就是模式，由于处在对象的第一层，所以也会直接去obj的第一层查找名为a的属性，然后赋值给变量p
//`a: [x]`也是一样，查找到名为a的属性后，并且确定他是一个数组，于是按数组的规则解构，那么直接使用一个'x'或'x,'就可以获取到数组第一个位置的值
//`a: [,{b: y}]`较复杂，a是模式为了查找到对象中的元素，下一层中是数组解构，所以无需名字，只需要指定位置，所以此时用一个','表示取第二个位置的值，第二个位置是个对象，要取其中的指定值就又需要指定名字查找，就是'b'，之后将其赋给变量y

//对象的解构也可使用默认值
//同数组解构赋值的默认值规则一样

//如果将一个已经声明的变量用于解构赋值，必须注意写法
let x;
({y:x} = {y:1});

//对象的解构赋值，对于对象内置属性和方法的复制来说，会变得非常简单，因为是直接通过名字查找的
let {log, sin ,cos} = Math;
//但注意，解构赋值是**浅复制**，对于对象中的复杂类型的数据，只会复制其指针

//因为数组本身是特殊的对象，所以可以对数组进行对象的解构赋值，模式是数组的index
let arr = [1,2,3];
let {0: a, [arr.length-1]: b} = arr;
//上例中方括号的写法为属性名表达式，属于新的对象的扩展
```

##### 字符串的解构赋值
```
//字符串在解构赋值时，是被转换成了类似数组的对象，每个字符按次序排列在数组中
let {a,b,c} = '123';
a // 1
b // 2
c // 3

//类似数组的对象都有一个length属性，因为字符串解构赋值是被转换成类似数组的对象，数组其实也是特殊的对象，所以追根究底，就是对象的解构赋值，所以无论是通过index找到的字符，还是通过length属性找到的对应的属性，都是可以解构赋值的
```

##### 数值和布尔值的解构赋值

同样，会先将数值和布尔值转换成对象，然后进行对象的解构赋值操作

##### 函数参数的解构赋值
```
//实际上就是将数组和对象的解构赋值
function([a,b]){};
function({}){};
//同数组和对象的解构赋值规则相同

//需要注意的是，在设置默认值时，要注意对象
function({x=0, y=0}){};
//这样的默认值设置无论是有一个参数不存在，或是都不存在的情况下，都将使用默认值
function(){{x,y} = {x:0, y:0}};
//而这样的则是为函数的整个参数对象设置默认值，也就是arguments对象，所以只有当整个参数对象为undefined时，才会使用默认值，无论是空对象还是缺少参数，都不会使用默认值

```

##### 圆括号问题

在某些情况下使用解构赋值并使用圆括号会导致一些歧义的产生，所以建议是最好不要在模式中放置圆括号

不能使用圆括号且使用就会报错的场景与情况有很多，而能使用圆括号的情况只有一种：**赋值语句的非模式部分，可以使用圆括号**

如`[(a)] = [1]`这种数组解构赋值，无需指明模式，a直接就是变量

又如`({p: (d)} = {})`这种对象解构赋值，p是模式，d是变量，圆括号用在d上，以及整个赋值表达式上，都是可以的

### 用途

1.交换变量的值
```
[x,y] = [y,x]
```
2.从函数返回多个值

当函数需要返回多个值时，多是以对象或数组形式返回，用解构赋值可以轻松的分解获得这些数据

3.函数参数的定义和默认值

多见于参数为一个对象，这样的解构赋值甚至不需要次序，和解构赋值的默认值配合使用，使函数内部的初始化工作甚至可以在函数声明时就完成预设
```
function(data, {
	a = true,
	b = function(){},
	c = 1,
	d = []
	}){};
```



4.提取JSON数据

JSON其实也是特殊的对象，所以只要指定键名(属性名)，解构赋值也会变得非常轻松和短

5.遍历map结构(for of方法)

Map结构暂时没了解，等之后了解后更改此部分内容
```
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world
```

6.输入模块的指定方法

实际上也是对象方法和属性的解构赋值
```
const { SourceMapConsumer, SourceNode } = require("source-map");
```
--------------------------------

### 字符串的扩展